# syntax=docker/dockerfile:1.6
# Multi-stage Dockerfile for RustFS - Using Alpine Linux
#
# IMPORTANT: This Dockerfile builds RustFS from source using Alpine Linux.
# Alpine provides smaller image size and musl-based binaries.
#
# Example:
#   docker build -f Dockerfile.new -t rustfs:alpine .
#   docker run --rm -p 9000:9000 rustfs:alpine
#
# Supports cross-compilation for amd64 and arm64 via TARGETPLATFORM.

ARG TARGETPLATFORM
ARG BUILDPLATFORM

# -----------------------------
# Build stage
# -----------------------------
FROM alpine:3.22 AS builder

# Re-declare args after FROM
ARG TARGETPLATFORM
ARG BUILDPLATFORM

# Debug: print platforms
RUN echo "Build info -> BUILDPLATFORM=${BUILDPLATFORM}, TARGETPLATFORM=${TARGETPLATFORM}"

# Install build toolchain and headers
RUN apk add --no-cache \
    rust \
    cargo \
    gcc \
    musl-dev \
    openssl-dev \
    pkgconfig \
    curl \
    git \
    protobuf-dev \
    protobuf-compiler \
    flatbuffers-compiler \
    build-base \
    linux-headers \
    bash

# Install rustup for better Rust version management (Alpine's rust package may be outdated)
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable

# Add rustup to PATH
ENV PATH="/root/.cargo/bin:${PATH}"

# Optional: cross toolchain for aarch64 (only when targeting linux/arm64)
RUN set -eux; \
    if [ "${TARGETPLATFORM:-linux/amd64}" = "linux/arm64" ]; then \
    apk add --no-cache gcc-aarch64-linux-gnu; \
    fi

# Add Rust targets based on TARGETPLATFORM (using musl for Alpine)
RUN set -eux; \
    case "${TARGETPLATFORM:-linux/amd64}" in \
    linux/amd64) rustup target add x86_64-unknown-linux-musl ;; \
    linux/arm64) rustup target add aarch64-unknown-linux-musl ;; \
    *) echo "Unsupported TARGETPLATFORM=${TARGETPLATFORM}" >&2; exit 1 ;; \
    esac

# Cross-compilation environment (used only when targeting aarch64)
ENV CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-gnu-gcc
ENV CC_aarch64_unknown_linux_musl=aarch64-linux-gnu-gcc
ENV CXX_aarch64_unknown_linux_musl=aarch64-linux-gnu-g++

WORKDIR /usr/src/rustfs

# Layered copy to maximize caching:
# 1) top-level manifests
COPY Cargo.toml Cargo.lock ./
# 2) workspace member manifests (adjust if workspace layout changes)
COPY rustfs/Cargo.toml rustfs/Cargo.toml
COPY crates/*/Cargo.toml crates/
COPY cli/rustfs-gui/Cargo.toml cli/rustfs-gui/Cargo.toml

# Pre-fetch dependencies for better caching
RUN --mount=type=cache,target=/root/.cargo/registry \
    --mount=type=cache,target=/root/.cargo/git \
    cargo fetch --locked || true

# 3) copy full sources (this is the main cache invalidation point)
COPY . .

# Cargo build configuration for lean release artifacts
ENV CARGO_NET_GIT_FETCH_WITH_CLI=true \
    CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse \
    CARGO_INCREMENTAL=0 \
    CARGO_PROFILE_RELEASE_DEBUG=false \
    CARGO_PROFILE_RELEASE_SPLIT_DEBUGINFO=off \
    CARGO_PROFILE_RELEASE_STRIP=symbols

# Generate protobuf/flatbuffers code (uses protoc/flatc from distro)
RUN --mount=type=cache,target=/root/.cargo/registry \
    --mount=type=cache,target=/root/.cargo/git \
    --mount=type=cache,target=/usr/src/rustfs/target \
    cargo run --bin gproto

# Build RustFS (target depends on TARGETPLATFORM, using musl for Alpine)
RUN --mount=type=cache,target=/root/.cargo/registry \
    --mount=type=cache,target=/root/.cargo/git \
    --mount=type=cache,target=/usr/src/rustfs/target \
    set -eux; \
    case "${TARGETPLATFORM:-linux/amd64}" in \
    linux/amd64) \
    echo "Building for x86_64-unknown-linux-musl"; \
    cargo build --release --locked --target x86_64-unknown-linux-musl --bin rustfs -j "$(nproc)"; \
    install -m 0755 target/x86_64-unknown-linux-musl/release/rustfs /usr/local/bin/rustfs \
    ;; \
    linux/arm64) \
    echo "Building for aarch64-unknown-linux-musl"; \
    cargo build --release --locked --target aarch64-unknown-linux-musl --bin rustfs -j "$(nproc)"; \
    install -m 0755 target/aarch64-unknown-linux-musl/release/rustfs /usr/local/bin/rustfs \
    ;; \
    *) \
    echo "Unsupported TARGETPLATFORM=${TARGETPLATFORM}" >&2; exit 1 \
    ;; \
    esac

# -----------------------------
# Runtime stage (Alpine minimal)
# -----------------------------
FROM alpine:3.22

ARG BUILD_DATE
ARG VCS_REF

LABEL name="RustFS (alpine)" \
    maintainer="RustFS Team" \
    build-date="${BUILD_DATE}" \
    vcs-ref="${VCS_REF}" \
    description="RustFS - built from source using Alpine Linux (NOT for production)."

# Minimal runtime deps
RUN apk add --no-cache \
    ca-certificates \
    tzdata \
    coreutils

# Create a conventional runtime user/group
RUN set -eux; \
    addgroup -g 1000 -S rustfs; \
    adduser -u 1000 -G rustfs -S rustfs -D

WORKDIR /app

# Prepare data/log directories with sane defaults
RUN set -eux; \
    mkdir -p /data /logs; \
    chown -R rustfs:rustfs /data /logs /app; \
    chmod 0750 /data /logs

# Copy the freshly built binary and the entrypoint
COPY --from=builder /usr/local/bin/rustfs /usr/bin/rustfs
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /usr/bin/rustfs /entrypoint.sh

# Default environment (override in docker run/compose as needed)
ENV RUSTFS_ADDRESS=":9000" \
    RUSTFS_ACCESS_KEY="rustfsadmin" \
    RUSTFS_SECRET_KEY="rustfsadmin" \
    RUSTFS_CONSOLE_ENABLE="true" \
    RUSTFS_VOLUMES="/data" \
    RUST_LOG="warn" \
    RUSTFS_OBS_LOG_DIRECTORY="/logs" \
    RUSTFS_USERNAME="rustfs" \
    RUSTFS_GROUPNAME="rustfs" \
    RUSTFS_UID="1000" \
    RUSTFS_GID="1000"

EXPOSE 9000 9001
VOLUME ["/data", "/logs"]

# Keep root here; entrypoint will drop privileges using chroot --userspec
ENTRYPOINT ["/entrypoint.sh"]
CMD ["/usr/bin/rustfs"]

